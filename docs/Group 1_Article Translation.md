# 第一组文档翻译（第一组）
## 第一篇 核心概念
<!-- TOC -->

- [核心概念](#核心概念)
  - [消息生产者](#消息生产者)
    - [生产者组](#生产者组)
  - [消息消费者](#消息消费者)
    - [拉取式消费者](#拉取式消费者)
    - [推动式消费者](#推动式消费者)
    - [消费者组](#消费者组)
  - [主题](#主题)
  - [消息](#消息)
    - [消息队列](#消息队列)
    - [标签](#标签)
    - [Broker服务器](#Broker服务器)
  - [名称服务](#名称服务)
  - [消息模型](#消息模型)
  - [消息顺序](#消息顺序)

<!-- /TOC -->
# 核心概念
![image.png](https://img.alicdn.com/tfs/TB1NIeFq77mBKNjSZFyXXbydFXa-511-274.png)
基于以上模型，我们能够更深入理解关于消息系统设计的一些主题：
* 消费者并发
* 消费者热点问题
* 消费者负载均衡
* 消息路由
* 连接多路复用
* 金丝雀部署
## 消息生产者
一个消息生产者会把业务应用系统里产生的消息发送到Broker服务器。RocketMQ提供多种发送
方式：同步，异步和单向。
### 生产者组
同类生产者，即发送同一类消息且发送逻辑一致的，会被归在一起。如果原始生产者在事务之后
崩溃，则Broker服务器可以联系同一生产者组的其他生产者实例来提交或回溯消费。
注意：考虑到已有的生产者在发送消息上足够强大，为了避免不必要的生产者实例初始化，每个
生产者组只允许有一个实例。
## 消息消费者
一个消息消费者会从Broker服务器拉取消息并将其提供给应用程序。在用户应用的角度而言，提
供两种类型的消费者：
### 拉取式消费者
拉取式消费者主动从Broker服务器获取消息。一旦获取了批量消息，用户应用程序就会启动消费
过程。
### 推动式消费者
另一方面，推动式消费者封装消息的拉取、消费进度和其他内部工作的维护，为端用户留下回调
接口以供在消息到达时实施。
### 消费者组
与之前提到的生产者组相似，起到相同作用的消费者会被归为一类并被命名为消费者组。
消费者组是一个很好的概念，它使得在消息消费方面实现负载均衡和容错的目标变得非常容易。
注意：消费者组的消费者实例必须有完全相同的主题订阅。
## 主题
主题是生产者传递消息和消费者拉取消息的类别。主题与生产者和消费者的关系是很松散的（不
是一一对应的）。具体而言，一个主题可能没有或者有一个或多个可发送消息的生产者，与此相
反，一个生产者可以发送包含不同主题的消息。从消费者角度而言，一个主题可能不被消费者组
订阅，也可能被消费者组订阅一次或多次，同样地，只要此组实例保持相同订阅，消费者组可订
阅一个或多个主题。
## 消息
消息即需要被传达的信息。一条消息必须包含一个主题，它可以被解释为将要发送的邮件地址。
消息还可以有可选标签和额外的键值对，比如可以为消息设置业务密钥，并在Broker服务器上查
找消息来诊断开发期间的问题。
### 消息队列
主题被划分为一个或多个子主题，即“消息队列”。
### 标签
标签，即子主题，为用户提供了更多的灵活性。有了标签以后，来自同一业务单元的消息，可以
根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并
优化RocketMQ提供的查询系统。
### Broker服务器
Broker服务器是RocketMQ系统的重要组成部分，它负责接收从生产者发送来的消息并存储，同
时为消费者的拉取请求作准备。Broker服务器也存储消息相关的元数据，包括消费者组、消费进
度偏移和主题或队列消息。
## 名称服务
名称服务充当路由消息的提供者。生产者或消费者能够查找主题来寻找相应的Broker列表。
## 消息模型
* 集群消费
* 广播消费
## 消息顺序
当使用DefaultMQPushConsumer时，用户可以决定顺序消费或是并发消费。
* 顺序消费

顺序消费消息意味着对于每个消息队列，消费消息的顺序要同发送消息的顺序一致。如果正在处理的场景要求是全局顺序的，需要确保此时使用的主题只有一个消息队列。

注意：如果指定了顺序消费，那么消息消费的最大并发性就是消费者组订阅的消息队列的数量。
* 并发消费

当需要并发消费消息，消息消费的最大的消息并发性只会受到每个消费者客户端指定的线程池的限制。

注意：在这种模式下，消息顺序是不被保证的。

---
**英文文档修改**

Consumer Group

Similar to previously mentioned producer group, consumers of the exactly same role are grouped together and named Consumer Group.

Consumer Group is a great concept, with which achieving goals of load-balance and fault-tolerance, in terms of message consuming, is super easy.
修改处：Consumer Group is a great concept with which achieving 此处应为非限制性定语从句。

---



## 第二篇 最佳实践指南之生产者

<!-- TOC -->

- [最佳实践指南之生产者](#最佳实践指南之生产者)
  - [发送状态](#发送状态)
    - [刷盘超时（FLUSH_DISK_TIMEOUT）](#刷盘超时flush_disk_timeout)
    - [数据同步到Slave服务器超时（FLUSH_SLAVE_TIMEOUT）](#数据同步到slave服务器超时flush_slave_timeout)
    - [无Slave服务器可用（SLAVE_NOT_AVAILABLE）](#无slave服务器可用slave_not_available)
    - [发送成功（SEND_OK）](#发送成功send_ok)
    - [重复或丢失（DuplicationorMissing）](#重复或丢失duplicationormissing)
  - [超时](#超时)
  - [消息大小](#消息大小)
  - [异步发送](#异步发送)
  - [生产者组](#生产者组)
  - [线程安全](#线程安全)
  - [性能](#性能)

<!-- /TOC -->
# 最佳实践指南之生产者
一些实用的使用提示
## 发送状态
发送一条消息后，将会返回一个SendResult对象，该对象包含了SendStatus.
首先，假设消息对象中的isWaitStoreMsgOK=true（默认true）。如果
isWaitStoreMsgOK=false，当没有捕获到异常，那么将返回SEND_OK.
以下对每个状态进行了说明：
### 刷盘超时（FLUSH_DISK_TIMEOUT）
消息存储配置参数中可以设置刷盘方式和同步刷盘时间长度，如果Broker服务器设置了刷
盘方式为同步刷盘即FlushDiskType=SYNC_FLUSH（默认为异步刷盘方式），当Broker
服务器未在同步刷盘时间内（默认为5s）完成刷盘，则将返回该状态——刷盘超时。
### 数据同步到Slave服务器超时（FLUSH_SLAVE_TIMEOUT）
如果Broker服务器的角色是同步Master即SYNC_MASTER（默认是异步Master服务器即
ASYNC_MASTER），并且从属Broker服务器未在同步刷盘时间（默认为5秒）内完成
与主服务器的同步，则将返回该状态——数据同步到Slave服务器超时。
### 无Slave服务器可用（SLAVE_NOT_AVAILABLE）
如果Broker服务器的角色是同步Master即SYNC_MASTER（默认是异步Master服务器即
ASYNC_MASTER），但没有配置slave Broker服务器，则将返回该状态——无Slave服务器可用。
### 发送成功（SEND_OK）
消息发送成功也不意味着它是可靠的。要确保不会丢失任何消息，还应启用同步Master服务器
或同步刷盘即SYNC_MASTER或SYNC_FLUSH。
### 重复或丢失（DuplicationorMissing）
如果返回值是刷盘超时（FLUSH_DISK_TIMEOUT），同步Slave服务器超时
（FLUSH_SLAVE_TIMEOUT）并且Broker服务器正好关闭，那么丢失的消息是可以找
到的。此时，有两个选择，一个是放弃该消息，这可能会导致此消息丢失;另一种方法是
重新发送消息，这可能会使消息重复。通常推荐重新发送消息，在客户端消费消息时过滤
重复消息，除非某些消息不重要，能够接受这些消息的丢失。但请记住，当返回值为无Slave服务器
可用（SLAVE_NOT_AVAILABLE）时，重新发送消息是无用的。如果发生这种情况，用
户应该保留场景并提醒群集管理器。
## 超时
客户端向Broker服务器发送请求，并等待响应，但如果最大等待时间已过，并且未返回任
何响应，则客户端将抛出请求远程超时异常即RemotingTimeoutException，默认等待
时间为3秒。用户还可以使用方法send（msg，timeout）而不是send（msg）传入超
时参数。请注意，不建议等待时间太小，因为Broker服务器需要一些时间来刷新磁盘，
并同步到从设备。如果该值远超于同步刷盘时间（syncFlushTimeout），则该值则没有太
大意义，因为Broker服务器可能会返回同步到Slave服务器超时（FLUSH_SLAVE_TIMEOUT），
或者在请求超时之前返回同步到Slave服务器超时（FLUSH_SLAVE_TIMEOUT）。
## 消息大小
建议消息的大小不要超过512K。
## 异步发送（AsyncSending）
默认方法send（msg）会在得到返回响应之前一直被阻塞。因此，如果用户重视性能，那
么建议使用send（msg，callback），这样消息发送将以异步方式进行。
## 生产者组
通常而言，生产者组没有什么作用。但是如果关系到事务，那么用户就需要关注到生产者组。默
认情况下，在同一个JVM中在一个生产者组只能创建一个相同的生产者，这通常就足够了。
## 线程安全
生产者是线程安全的，可以在业务中使用。
## 性能
如果希望在一个JVM中有多个生产者来进行大数据处理，有以下建议：
* 通过一些生产者（3~5个足以）使用异步发送
* 为每个生产者的设置实例名即setInstanceName
